import{_ as t,o as e,c as a,R as i}from"./chunks/framework.OBNbGUgv.js";const m=JSON.parse('{"title":"FFIの方針","description":"","frontmatter":{},"headers":[],"relativePath":"reference/developer/languages/ffi.md","filePath":"reference/developer/languages/ffi.md","lastUpdated":1704004113000}'),l={name:"reference/developer/languages/ffi.md"},d=i('<h1 id="ffiの方針" tabindex="-1">FFIの方針 <a class="header-anchor" href="#ffiの方針" aria-label="Permalink to &quot;FFIの方針&quot;">​</a></h1><p>webassemblyの数値型はi32,i64,f32,f64のみである． Go,C/C++,Rustではより多くの型が存在するが，例えばint8などを用いてもwebassemblyへのコンパイル時により大きな型に入れられてしまう． さらに型の違いにより，適切に値が使用できないことがわかっているため，webassemblyへのコンパイル前，実行時リンクの両方に置いて型をwebassemblyの型に合わせる．</p><p>下記の表の通りである．</p><table><thead><tr><th>webassemblyでの型</th><th>mahiwa-backendでの型</th><th>mahiwa-frontend-rustでの型</th><th>mahiwa-frontend-goでの型</th><th>wasm3 i_signatureでの型</th></tr></thead><tbody><tr><td>i32</td><td>int,long,int8_t,int16_t,int32_t,uint8_t,uint16_t,</td><td>i32</td><td>int32</td><td>i</td></tr><tr><td>i64</td><td>int64_t,unsigned int,unsigned long, uint32_t,(uint64_t)</td><td>i64</td><td>int64</td><td>I</td></tr><tr><td>f32</td><td>float,float_t</td><td>f32</td><td>float32</td><td>f</td></tr><tr><td>f64</td><td>double,double_t</td><td>f64</td><td>float64</td><td>F</td></tr></tbody></table><h3 id="c-c-での補足" tabindex="-1">C/C++での補足 <a class="header-anchor" href="#c-c-での補足" aria-label="Permalink to &quot;C/C++での補足&quot;">​</a></h3><p>Mahiwaの想定環境に置いて型をsizeofで調べたところ，<a href="https://github.com/project-mahiwa/benchmark-c/issues/11" target="_blank" rel="noreferrer">https://github.com/project-mahiwa/benchmark-c/issues/11</a> の通りとなった．</p><p>このことを踏まえると</p><ul><li>int,long,unsigned longは同じ大きさであり，どれも4byteである</li><li>floatは4byte, doubleは8byteである</li><li>int32_t,int64_tでは名前と同様のサイズを確保できている</li><li>現状ではuint64_tの存在はないが，出てきた場合は桁溢れの可能性が有りつつもint64_tと同等とする</li></ul><p>ことから先述のような型の変換とした．</p><h2 id="型" tabindex="-1">型 <a class="header-anchor" href="#型" aria-label="Permalink to &quot;型&quot;">​</a></h2><h3 id="c-c-to-wasm3" tabindex="-1">C/C++ to wasm3 <a class="header-anchor" href="#c-c-to-wasm3" aria-label="Permalink to &quot;C/C++ to wasm3&quot;">​</a></h3><ul><li>原則PlatformIOで読んでいるライブラリ関数の型に従う</li><li>Cでのdoubleはf64で表現.</li><li>実装がマクロなどで最適化されており型がない場合はintを中心とした適切な型を採用</li><li>Arduino側の定義でintになっているところは32bitでマイコンが動くことを想定してi32とする</li></ul><h3 id="languages-to-webassembly" tabindex="-1">Languages to WebAssembly <a class="header-anchor" href="#languages-to-webassembly" aria-label="Permalink to &quot;Languages to WebAssembly&quot;">​</a></h3><ul><li>WebAssemblyにはi32,i64,f32,f64しかないのでuint8などを使うことでメモリ削減などに繋がらないが、将来の型対応やオーバーフローをコンパイラのレベルで防ぐことを目的として、mahiwa-backend側に合わせる。</li></ul><h2 id="定数" tabindex="-1">定数 <a class="header-anchor" href="#定数" aria-label="Permalink to &quot;定数&quot;">​</a></h2><ul><li>WebAssemblyを経由するタイミングで数値になる上、Arduinoの定数系も実際は数値なので、最初から数値だと無駄がない</li><li>ドキュメントに明記する</li></ul><h2 id="関数名" tabindex="-1">関数名 <a class="header-anchor" href="#関数名" aria-label="Permalink to &quot;関数名&quot;">​</a></h2><ul><li>ライブラリとするプログラミング言語側を優先する</li></ul>',18),n=[d];function r(o,s,h,u,b,c){return e(),a("div",null,n)}const _=t(l,[["render",r]]);export{m as __pageData,_ as default};
