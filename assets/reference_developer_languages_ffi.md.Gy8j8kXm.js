import{_ as e,o as a,c as l,R as t}from"./chunks/framework.OBNbGUgv.js";const m=JSON.parse('{"title":"FFIの方針","description":"","frontmatter":{},"headers":[],"relativePath":"reference/developer/languages/ffi.md","filePath":"reference/developer/languages/ffi.md","lastUpdated":1702386428000}'),i={name:"reference/developer/languages/ffi.md"},o=t('<h1 id="ffiの方針" tabindex="-1">FFIの方針 <a class="header-anchor" href="#ffiの方針" aria-label="Permalink to &quot;FFIの方針&quot;">​</a></h1><h2 id="型" tabindex="-1">型 <a class="header-anchor" href="#型" aria-label="Permalink to &quot;型&quot;">​</a></h2><h3 id="c-c-to-wasm3" tabindex="-1">C/C++ to wasm3 <a class="header-anchor" href="#c-c-to-wasm3" aria-label="Permalink to &quot;C/C++ to wasm3&quot;">​</a></h3><ul><li>原則PlatformIOで読んでいるライブラリ関数の型に従う</li><li>Cでのdoubleはf64で表現.</li><li>実装がマクロなどで最適化されており型がない場合はintを中心とした適切な型を採用</li><li>Arduino側の定義でintになっているところは32bitでマイコンが動くことを想定してi32とする</li></ul><h3 id="languages-to-webassembly" tabindex="-1">Languages to WebAssembly <a class="header-anchor" href="#languages-to-webassembly" aria-label="Permalink to &quot;Languages to WebAssembly&quot;">​</a></h3><ul><li>WebAssemblyにはi32,i64,f32,f64しかないのでuint8などを使うことでメモリ削減などに繋がらないが、将来の型対応やオーバーフローをコンパイラのレベルで防ぐことを目的として、mahiwa-backend側に合わせる。</li></ul><h2 id="定数" tabindex="-1">定数 <a class="header-anchor" href="#定数" aria-label="Permalink to &quot;定数&quot;">​</a></h2><ul><li>WebAssemblyを経由するタイミングで数値になる上、Arduinoの定数系も実際は数値なので、最初から数値だと無駄がない</li><li>ドキュメントに明記する</li></ul><h2 id="関数名" tabindex="-1">関数名 <a class="header-anchor" href="#関数名" aria-label="Permalink to &quot;関数名&quot;">​</a></h2><ul><li>ライブラリとするプログラミング言語側を優先する</li></ul>',10),r=[o];function s(n,d,c,h,u,f){return a(),l("div",null,r)}const _=e(i,[["render",s]]);export{m as __pageData,_ as default};
